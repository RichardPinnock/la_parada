// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id       String  @id @default(cuid())
  name     String?
  email    String  @unique
  password String
  posts    Post[]
  role     String  @default("admin")
  isActive Boolean @default(true)
  
  sales          Sale[]
  purchases      Purchase[]
  adjustments    InventoryAdjustment[]
  shifts         Shift[]
  stockLocations UserStockLocation[]
  movements      InventoryMovement[]
}

model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title     String
  content   String?
  published Boolean  @default(false)
  authorId  String?
  author    User?    @relation(fields: [authorId], references: [id])
}

model Product {
  id            Int     @id @default(autoincrement())
  name          String
  purchasePrice Float
  salePrice     Float
  imageName     String
  stock         Int
  isActive      Boolean @default(true)
  notes         String?

  salesItems      SaleItem[]
  purchaseItems   PurchaseItem[]
  warehouseStocks WarehouseStock[]
  adjustments     InventoryAdjustment[]
  movements       InventoryMovement[]
  snapshots       ShiftStockSnapshot[]
}

model StockLocation {
  id            String @id @default(uuid())
  name          String @unique // Ej: "Almacén Central", "Sucursal A"
  isActive      Boolean @default(true)

  stock       WarehouseStock[]
  sales       SaleItem[]
  purchases   PurchaseItem[]
  adjustments InventoryAdjustment[]
  movements   InventoryMovement[]
  userLinks   UserStockLocation[]
  shifts      Shift[]
  snapshots   ShiftStockSnapshot[]
}

model UserStockLocation {
  userId          String
  stockLocationId String

  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  stockLocation StockLocation @relation(fields: [stockLocationId], references: [id], onDelete: Cascade)

  @@id([userId, stockLocationId])
}

model WarehouseStock {
  id         String @id @default(uuid())
  productId  Int
  locationId String
  quantity   Int

  product  Product       @relation(fields: [productId], references: [id])
  location StockLocation @relation(fields: [locationId], references: [id])

  @@unique([productId, locationId]) // Un producto no puede repetirse en la misma ubicación
}

model Sale {
  id              String   @id @default(uuid())
  userId          String // Usuario que realizó la venta
  shiftId         String // Turno en que se hizo
  paymentMethodId String // Método de pago usado
  total           Float
  transferCode    String?
  createdAt       DateTime @default(now())

  user          User          @relation(fields: [userId], references: [id])
  shift         Shift         @relation(fields: [shiftId], references: [id])
  items         SaleItem[]
  paymentMethod PaymentMethod @relation(fields: [paymentMethodId], references: [id])
  @@index([createdAt])
}

model SaleItem {
  id         String @id @default(uuid())
  saleId     String
  productId  Int
  locationId String // Ubicación desde donde se vendió
  quantity   Int
  unitPrice  Float // Precio por unidad en ese momento
  total      Float // quantity * unitPrice

  sale     Sale          @relation(fields: [saleId], references: [id])
  product  Product       @relation(fields: [productId], references: [id])
  location StockLocation @relation(fields: [locationId], references: [id])
  costAllocations SaleItemCostAllocation[]
  @@index([locationId, productId])
  @@index([saleId])
}

model Purchase {
  id        Int @id @default(autoincrement())
  userId    String // Usuario que registró la compra
  total     Float
  createdAt DateTime @default(now())

  user  User           @relation(fields: [userId], references: [id])
  items PurchaseItem[]
  @@index([createdAt])
}

model PurchaseItem {
  id         String @id @default(uuid())
  purchaseId Int
  productId  Int
  locationId String // Ubicación a donde entra el producto
  quantity   Int
  unitCost   Float // Costo por unidad en esa compra
  totalCost  Float // quantity * unitCost

  purchase Purchase      @relation(fields: [purchaseId], references: [id])
  product  Product       @relation(fields: [productId], references: [id])
  location StockLocation @relation(fields: [locationId], references: [id])
  costAllocations SaleItemCostAllocation[]
  @@index([locationId, productId])
  @@index([purchaseId])
}

model InventoryAdjustment {
  id         String   @id @default(uuid())
  productId  Int
  quantity   Int
  reason     String
  userId     String
  locationId String
  createdAt  DateTime @default(now())

  product  Product       @relation(fields: [productId], references: [id])
  user     User          @relation(fields: [userId], references: [id])
  location StockLocation @relation(fields: [locationId], references: [id])
}

model PaymentMethod {
  id   String @id @default(uuid()) // Identificador único
  name String @unique // Nombre del método de pago (Ej: Efectivo, Transferencia)

  // Relaciones
  sales Sale[]
}

model InventoryMovement {
  id           String       @id @default(uuid())
  productId    Int
  locationId   String
  quantity     Int
  movementType MovementType // ENUM: SALE, PURCHASE, ADJUSTMENT, TRANSFER
  reference    String? // Opcional: ID de venta/compra relacionada/ en caso de transfer tiene el mismo id las dos transfer
  userId       String
  createdAt    DateTime     @default(now())

  user   User @relation(fields: [userId], references: [id])
  product  Product       @relation(fields: [productId], references: [id])
  location StockLocation @relation(fields: [locationId], references: [id])
  @@index([locationId, createdAt])
  @@index([productId, movementType])
}

model Shift {
  id              String    @id @default(uuid())
  userId          String
  startTime       DateTime
  endTime         DateTime?
  startAmount     Float // Cantidad de efectivo o inventario al iniciar
  endAmount       Float? // Cantidad al terminar
  createdAt       DateTime  @default(now())
  stockLocationId String

  user          User          @relation(fields: [userId], references: [id])
  sales         Sale[]
  stockLocation StockLocation @relation(fields: [stockLocationId], references: [id])
  snapshots ShiftStockSnapshot[]
}

model ShiftStockSnapshot {
  id          String @id @default(uuid())
  shiftId     String
  productId   Int
  locationId  String
  type        String  //START-END
  quantity    Int
  createdAt   DateTime @default(now())

  shift       Shift @relation(fields: [shiftId], references: [id])
  product     Product @relation(fields: [productId], references: [id])
  location    StockLocation @relation(fields: [locationId], references: [id])
  @@index([locationId, type, createdAt])
  @@index([shiftId])
}

enum MovementType {
  SALE
  PURCHASE
  ADJUSTMENT
  TRANSFER
}

model SaleItemCostAllocation { //este modelo es para saber mejor las ganancias
  id            String @id @default(uuid())
  saleItemId    String
  purchaseItemId String
  quantityUsed  Int
  unitCost      Float

  saleItem      SaleItem      @relation(fields: [saleItemId], references: [id])
  purchaseItem  PurchaseItem  @relation(fields: [purchaseItemId], references: [id])
}